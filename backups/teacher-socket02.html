<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teacher AI Client</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Styles for better visual separation and interaction */
        body { font-family: "Inter", sans-serif; background-color: #f3f4f6; }
        .my-container { max-width: 1000px; margin: 0 auto; padding: 20px; }
        
        .my-chat-log { 
            height: 60vh; 
            overflow-y: auto; 
            padding: 15px; 
            background-color: white; 
            border-radius: 8px; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); 
            margin-top: 15px; 
            border: 1px solid #e5e7eb;
        }
        
        /* Message Styling */
        .my-message-bubble { margin-bottom: 15px; padding: 10px; border-radius: 8px; }
        .my-message-student { background-color: #e0f2f1; border-left: 4px solid #0d9488; } /* Teal for Student */
        .my-message-ai { background-color: #eef2ff; border-left: 4px solid #4f46e5; } /* Indigo for AI */
        .my-message-system { background-color: #fef3c7; border-left: 4px solid #f59e0b; text-align: center; } /* Yellow for System */
        .my-message-error { background-color: #fee2e2; border-left: 4px solid #ef4444; } /* Red for Error */
        
        .my-message-header { font-weight: 700; font-size: 14px; margin-bottom: 4px; }
        .my-message-time { font-size: 10px; color: #6b7280; float: right; }

        /* Grouping Styles */
        .my-student-thread { 
            border: 1px solid #d1d5db; 
            border-radius: 8px; 
            margin-bottom: 20px; 
            padding: 15px;
            background-color: #ffffff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .my-thread-header { 
            font-size: 18px; 
            font-weight: 800; 
            color: #4f46e5; 
            margin-bottom: 10px; 
            padding-bottom: 5px; 
            border-bottom: 2px solid #eef2ff;
        }
    </style>
</head>
<body>

    <div class="my-container">
        <h1 class="text-3xl font-extrabold text-center text-indigo-700 mb-4">Teacher AI Client</h1>
        
        <div id="myConnectionStatus" class="text-center p-2 mb-4 rounded-lg font-semibold text-red-700 bg-red-100">
            Status: Disconnected.
        </div>

        <!-- Connection and Configuration -->
        <div class="bg-white p-4 rounded-lg shadow-md mb-6 space-y-3">
            <div class="flex items-center space-x-4">
                <label for="myApiKeyInput" class="font-bold text-gray-700 w-1/4">Gemini API Key:</label>
                <input type="password" id="myApiKeyInput" placeholder="Enter your API Key" class="p-2 border border-gray-300 rounded-lg flex-grow" />
            </div>
            <div class="flex items-center space-x-4">
                <label for="myServerAddressInput" class="font-bold text-gray-700 w-1/4">WebSocket URL:</label>
                <input type="text" id="myServerAddressInput" value="ws://localhost:8080" placeholder="e.g., ws://192.168.1.10:8080" class="p-2 border border-gray-300 rounded-lg flex-grow" />
                <button id="myConnectButton" onclick="myInitWebSocket()" class="px-4 py-2 bg-green-500 text-white font-bold rounded-lg hover:bg-green-600 transition disabled:opacity-50">Connect</button>
            </div>
            
            <div class="flex items-center space-x-4 pt-2 border-t border-gray-200">
                <label for="myGroupingToggle" class="font-bold text-gray-700 w-1/4 flex items-center">
                    <input type="checkbox" id="myGroupingToggle" onclick="myToggleGrouping()" class="mr-2 h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                    Group by Student Name
                </label>
                <span id="myQueueStatus" class="flex-grow text-sm font-medium text-yellow-600">Queue: Idle (0 waiting)</span>
            </div>
        </div>

        <!-- Chat Log Area -->
        <div id="myChatLog" class="my-chat-log">
            <div class="my-message-system">--- System: Enter your API key and connect to begin receiving student messages. ---</div>
        </div>
        
    </div>

    <script>
        // --- Global Variables ---
        let myWebSocket;
        let myApiKey = "";
        
        // --- Concurrency and Grouping Variables ---
        let myIsProcessing = false; // Lock to prevent concurrent LLM calls
        let myMessageQueue = [];    // Queue for holding pending student requests {name, text}
        let myStudentThreads = {};  // Stores student-specific HTML elements for grouped view: { 'Alice': divElement, ... }
        
        // --- DOM Elements ---
        const myChatLog = document.getElementById('myChatLog');
        const myConnectionStatus = document.getElementById('myConnectionStatus');
        const myApiKeyInput = document.getElementById('myApiKeyInput');
        const myServerAddressInput = document.getElementById('myServerAddressInput');
        const myConnectButton = document.getElementById('myConnectButton');
        const myGroupingToggle = document.getElementById('myGroupingToggle');
        const myQueueStatus = document.getElementById('myQueueStatus');

        // --- Core WebSocket Functions ---

        async function myInitWebSocket() {
            myApiKey = myApiKeyInput.value.trim();
            const myServerUrl = myServerAddressInput.value.trim();

            if (!myApiKey) {
                myDisplaySystemMessage("Please enter your Gemini API Key.", 'error');
                return;
            }
            if (!myServerUrl) {
                myDisplaySystemMessage("Please enter a WebSocket URL.", 'error');
                return;
            }
            
            myApiKeyInput.disabled = true;
            myServerAddressInput.disabled = true;
            myConnectButton.disabled = true;

            if (myWebSocket && myWebSocket.readyState !== WebSocket.CLOSED) {
                myWebSocket.close(1000, 'Reconnecting');
            }

            myConnectionStatus.textContent = "Status: Connecting to " + myServerUrl + "...";
            myConnectionStatus.className = 'text-center p-2 mb-4 rounded-lg font-semibold text-yellow-700 bg-yellow-100';
            
            try {
                myWebSocket = new WebSocket(myServerUrl);

                myWebSocket.onopen = async () => {
                    myConnectionStatus.textContent = "Status: Connected. Listening for student prompts.";
                    myConnectionStatus.className = 'text-center p-2 mb-4 rounded-lg font-semibold text-green-700 bg-green-100';
                    myDisplaySystemMessage(`Connection established to chat server. AI is ready.`, 'system');
                };

                myWebSocket.onmessage = async (myEvent) => {
                    const myIncomingMessage = myEvent.data;
                    
                    // 1. Check if it's a student question (format: "Name: Text")
                    const myMatch = myIncomingMessage.match(/^([^:]+):\s*(.*)$/);
                    
                    if (myMatch) {
                        const myStudentName = myMatch[1].trim();
                        const myStudentPrompt = myMatch[2].trim();
                        
                        // We ONLY want to handle questions that are NOT from the Teacher AI itself
                        if (myStudentName.toLowerCase().includes('teacher ai')) {
                            // This is an AI response being broadcast back. Just display it.
                            myDisplayMessage(myIncomingMessage, 'ai');
                        } else {
                            // This is a new student question. Queue it up.
                            myMessageQueue.push({ myStudentName, myStudentPrompt });
                            myUpdateQueueStatus();
                            myDisplayMessage(myIncomingMessage, 'student'); // Display the prompt immediately
                            
                            // Start processing the queue if not already running
                            myProcessQueue();
                        }
                    } else {
                        // Display any other unformatted messages (e.g., system messages from other clients)
                        myDisplayMessage(myIncomingMessage, 'other');
                    }
                };

                myWebSocket.onclose = async (myEvent) => {
                    myConnectionStatus.textContent = "Status: Disconnected. Click Connect to restart.";
                    myConnectionStatus.className = 'text-center p-2 mb-4 rounded-lg font-semibold text-red-700 bg-red-100';
                    myApiKeyInput.disabled = false;
                    myServerAddressInput.disabled = false;
                    myConnectButton.disabled = false;
                };

            } catch (myError) {
                myDisplaySystemMessage("Failed to connect WebSocket.", 'error');
                console.error("WebSocket Connection Error:", myError);
            }
        }

        // --- Concurrency and LLM Processing ---

        async function myProcessQueue() {
            if (myIsProcessing || myMessageQueue.length === 0) {
                return; // Already processing or queue is empty
            }

            myIsProcessing = true;
            myUpdateQueueStatus();

            while (myMessageQueue.length > 0) {
                // Get the next item from the queue
                const myRequest = myMessageQueue.shift(); 
                myUpdateQueueStatus();

                const { myStudentName, myStudentPrompt } = myRequest;
                
                myDisplaySystemMessage(`Processing prompt for ${myStudentName}...`, 'system');
                
                let myAIResponseText = "Sorry, I encountered an error while processing that question.";

                try {
                    myAIResponseText = await myCallGeminiAPI(myStudentPrompt);
                } catch (e) {
                    console.error("Gemini API Error:", e);
                    myDisplaySystemMessage(`Error for ${myStudentName}: ${e.message}`, 'error');
                }

                // 3. Format and Broadcast the AI response
                const myFullAIResponse = `Teacher AI to ${myStudentName}: ${myAIResponseText}`;
                
                if (myWebSocket && myWebSocket.readyState === WebSocket.OPEN) {
                    myWebSocket.send(myFullAIResponse);
                    // The onmessage handler will receive this broadcast and display it as 'ai'
                } else {
                    myDisplaySystemMessage(`Response for ${myStudentName} generated but failed to send (WebSocket closed).`, 'error');
                }
            }

            myIsProcessing = false;
            myUpdateQueueStatus();
            myDisplaySystemMessage("Queue is clear.", 'system');
        }

        async function myCallGeminiAPI(myPrompt) {
            const mySystemPrompt = "You are a helpful and supportive educational assistant. Answer student questions concisely and clearly, using simple language appropriate for a high school level. Do not mention your own role or persona in the response.";
            const myModel = "gemini-2.5-flash-preview-05-20";
            const myApiUrl = \`https://generativelanguage.googleapis.com/v1beta/models/\${myModel}:generateContent?key=\${myApiKey}\`;

            const myPayload = {
                contents: [{ parts: [{ text: myPrompt }] }],
                tools: [{ "google_search": {} }],
                systemInstruction: {
                    parts: [{ text: mySystemPrompt }]
                },
            };

            let myResponse;
            // Retry logic with exponential backoff
            for (let myAttempt = 0; myAttempt < 3; myAttempt++) {
                try {
                    myResponse = await fetch(myApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(myPayload)
                    });

                    if (myResponse.ok) {
                        const myResult = await myResponse.json();
                        return myResult.candidates?.[0]?.content?.parts?.[0]?.text || "No response text found.";
                    } else if (myResponse.status === 429) {
                        // Rate limit exceeded, wait and retry
                        const myDelay = Math.pow(2, myAttempt) * 1000;
                        await new Promise(myResolve => setTimeout(myResolve, myDelay));
                        continue;
                    } else {
                        throw new Error(\`API request failed with status: \${myResponse.status}\`);
                    }
                } catch (e) {
                    if (myAttempt === 2) throw new Error(\`Failed to fetch from Gemini: \${e.message}\`);
                    // Non-rate limit error, wait and retry
                    const myDelay = Math.pow(2, myAttempt) * 1000;
                    await new Promise(myResolve => setTimeout(myResolve, myDelay));
                }
            }
            return "Failed to get a response after multiple retries.";
        }

        // --- UI & Display Logic ---

        function myUpdateQueueStatus() {
            const myStatus = myIsProcessing 
                ? \`Queue: Processing... (\${myMessageQueue.length} waiting)\`
                : \`Queue: Idle (\${myMessageQueue.length} waiting)\`;
            myQueueStatus.textContent = myStatus;
        }

        function myToggleGrouping() {
            // Re-render based on the new toggle state
            myRefreshChatView();
        }

        function myGetStudentNameFromMessage(myText) {
             const myMatch = myText.match(/^(?:Teacher AI to )?([^:]+):\s*(.*)$/i);
             // Returns the first captured group (the name)
             return myMatch ? myMatch[1].replace('Teacher AI', '').trim() : null; 
        }

        function myDisplayMessage(myText, myType) {
            const myStudentName = myGetStudentNameFromMessage(myText);
            const myIsGrouped = myGroupingToggle.checked;
            
            // 1. Prepare message content and type
            let myContent = myText;
            let myMessageClass = '';
            let myHeader = '';
            
            if (myType === 'student') {
                myMessageClass = 'my-message-student';
                myHeader = \`\${myStudentName} asks: \`;
                myContent = myText.replace(myStudentName + ':', '').trim();
            } else if (myType === 'ai') {
                myMessageClass = 'my-message-ai';
                myHeader = \`AI response to \${myStudentName}: \`;
                // Remove the "Teacher AI to Name:" prefix for clean display
                myContent = myText.replace(/Teacher AI to [^:]+:\s*/i, '').trim(); 
            } else if (myType === 'system') {
                myMessageClass = 'my-message-system';
                myHeader = 'SYSTEM';
            } else if (myType === 'error') {
                myMessageClass = 'my-message-error';
                myHeader = 'ERROR';
            }
            
            // 2. Create the message bubble element
            const myNewMessageDiv = document.createElement('div');
            myNewMessageDiv.classList.add('my-message-bubble', myMessageClass);
            myNewMessageDiv.setAttribute('data-student-name', myStudentName || 'system');
            
            const myTime = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            
            myNewMessageDiv.innerHTML = \`
                <div class="my-message-header">\${myHeader}<span class="my-message-time">\${myTime}</span></div>
                <div>\${myContent}</div>
            \`;

            // 3. Store or display based on grouping state
            if (myIsGrouped && myStudentName && (myType === 'student' || myType === 'ai')) {
                // Grouped mode: Append to the student's thread
                myEnsureStudentThreadExists(myStudentName);
                myStudentThreads[myStudentName].appendChild(myNewMessageDiv);
                myStudentThreads[myStudentName].lastElementChild.scrollIntoView({ behavior: 'smooth' });
            } else {
                // Stream mode or System/Error messages: Append to the main log
                myChatLog.appendChild(myNewMessageDiv);
                myChatLog.scrollTop = myChatLog.scrollHeight;
            }
            
            // Also store the message data for later re-rendering
            // We'll rely on the DOM elements existing in the log for simplicity in this version
        }

        function myEnsureStudentThreadExists(myStudentName) {
            if (!myStudentThreads[myStudentName]) {
                const myThreadDiv = document.createElement('div');
                myThreadDiv.classList.add('my-student-thread');
                myThreadDiv.id = \`thread-\${myStudentName.replace(/\\s+/g, '-')}\`; // Simple sanitization
                myThreadDiv.innerHTML = \`<div class="my-thread-header">\${myStudentName}</div>\`;
                
                myStudentThreads[myStudentName] = myThreadDiv;
                
                // Add to the log if in grouped mode
                if (myGroupingToggle.checked) {
                    myChatLog.appendChild(myThreadDiv);
                }
            }
        }

        function myRefreshChatView() {
            const myAllMessages = Array.from(myChatLog.querySelectorAll('.my-message-bubble, .my-message-system, .my-message-error'));
            
            // Clear the main log
            myChatLog.innerHTML = '';
            
            if (myGroupingToggle.checked) {
                // Grouped View: Show threads
                for (const name in myStudentThreads) {
                    const myThreadDiv = myStudentThreads[name];
                    // Clear existing content in the thread body (keep header)
                    const myHeader = myThreadDiv.querySelector('.my-thread-header');
                    myThreadDiv.innerHTML = '';
                    myThreadDiv.appendChild(myHeader);
                    
                    myChatLog.appendChild(myThreadDiv);
                }
                
                // Re-append messages to their threads
                myAllMessages.forEach(myMessage => {
                    const myName = myMessage.getAttribute('data-student-name');
                    if (myName && myName !== 'system') {
                         myEnsureStudentThreadExists(myName);
                         myStudentThreads[myName].appendChild(myMessage.cloneNode(true));
                    } else {
                        // System/Error messages stay in the main stream (even in grouped mode)
                        myChatLog.appendChild(myMessage.cloneNode(true));
                    }
                });
            } else {
                // Stream View: Show all messages sequentially
                // Just re-append all messages to the main log
                myAllMessages.forEach(myMessage => myChatLog.appendChild(myMessage));
            }

            myChatLog.scrollTop = myChatLog.scrollHeight;
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            myRefreshChatView();
            // Automatically check for __api_key if the environment provides it
            if (typeof __api_key !== 'undefined') {
                myApiKeyInput.value = __api_key;
            }
        });
    </script>
</body>
</html>
